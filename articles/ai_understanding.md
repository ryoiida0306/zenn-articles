---
title: "AIにおける学習とは何なのかを高校生にもわかるように説明する"
emoji: "🤖"
type: "tech"
topics: ["AI", "機械学習", "ディープラーニング"]
published: true
---


# 学習とはいったい何なんだろう？

昨今身近に使われるAIとしてChatGPTがあります。
ユーザーである私たちがChatGPTをテキストに入力すると、そのテキストに対してChatGPTが返答をしてくれます。このChatGPTは、AIの一種である自然言語処理というものを使って、私たちのテキストを理解し、適切な返答をしてくれます。ChatGPTが作られる背景には、ウェキペディアのようなプラットフォームから大量のテキストデータを拾ってきて、AIが学習をしています。
しかし、言葉だけで「学習」といわれても、実際にどんなことをしているのか想像がつきません。
また、ChatGPT以外でも、テキストを入力すると、それに基づいた画像を生成してくれるAIや、音声を入力すると、それに基づいたテキストを生成してくれるAIなどがあります。
とにかく、AIを使うと「何かを入力すると、それに基づいた何かを出力してくれる」ということができるようになります。
しかし、何故そのような多種多様なことができるかはよくわかりません。

そこで今回は、AIとは何かを高校生にもわかるように少しだけ粒度を落として説明していきます。

## AIの実態
簡単な例として、手書きで数字が書いてある画像を入力すると、その数字が3であるか、否かを判別するAIを考えます。
実際に判別する際には以下の手順で行います。

1. 画像をピクセルごとに分解して、それぞれのピクセルの色を0から255の数値で表現します。例えば、28x28ピクセルの画像であれば、784個の数値が得られます。それぞれの数値を$x_1, x_2, ..., x_{784}$とします。
2. これらの数値を入力として、関数$F(\cdot)$に代入し、$F(x_1, x_2, ..., x_{784})$を計算します。計算した値を$z$とします。
3. $z$を確率の形式に整えるため、$z$を0から1の範囲に収めるための関数$\sigma(x)=\frac 1 {1+e^{-x}}$(後程解説します)に代入し、$\sigma(z)$を計算します。計算した値を$\hat{y}$とします。
4. $\hat{y}$が0.5以上1以下であれば、画像に書かれている数字は3であると判定します。0以上0.5未満の場合は、3でないと判定します。

![手書き数字の判別](/images/articles/ai_understanding/model.png)

AIが学習する部分は、関数$F(\cdot)$の中身を決めるパラメータを表す数値です。

## 学習とは

AIが学習するとは、関数$F(\cdot)$の中身を決めるパラメータを、大量のデータを使って決定することです。
単純な例として、以下の問題を考えます。

> 問題: 入力される数字を$x$として、$3x$が$5$を超えるか否かを判定するAIを作成するように、関数$F(x)=wx+b$のパラメータ$w,b$を決定する。

まず、この問題を学習せずに$w,b$を決め打ちで決定することを考えます。
AIの出力では、あくまで確率を出力として出す必要があるため、そのための関数としてシグモイド関数$\sigma(z)$を使います。
この関数は、$z$が大きいほど1に近づき、$z$が小さいほど0に近づく関数です。また、$z$が0以上の時、$\sigma(z)$は0.5以上1以下の値を取り、$z$が0未満の時、$\sigma(z)$は0以上0.5未満の値を取ります。
つまり、入力されるすべての実数に対する写像が存在して、常に0から1の範囲の値を取ることができます。

$$
\sigma(z) = \frac 1 {1+e^{-z}}
$$

![シグモイド関数](/images/articles/ai_understanding/sigmoid.png )

また、シグモイド関数には以下の性質があります。

$$
\begin{align*}
0.5 &\leq \hat{y} = \sigma(z) = \frac 1 {1+e^{-z}} \\
\Leftrightarrow e^{-z} &\leq 1 \\
\Leftrightarrow z &\geq 0
\end{align*}
$$

入力変数$z$が0以上の時、$\hat{y}$は0.5以上1以下の値を取ることがわかります。同様にして、入力変数$z$が0未満の時、$\hat{y}$は0以上0.5未満の値を取ることがわかります。
つまり、$3x$が$5$を超える時、$F(x)$を0以上に、そうでない時、$F(x)$を0未満にするように、$w,b$を決定すれば良いことがわかります。
よって、例えば$w=3, b=-5$とすることで、$3x$が$5$を超える時、$F(x)$は0以上に、そうでない時、$F(x)$は0未満になります。

しかし、このように$w,b$を決め打ちで決定することは、あまり汎用的とは言えません。そこで、データを用いて$w,b$を決定することを考えます。

データセットとして考えるものとして、以下のようなものが考えられます。
$(x,y) = \{(1,0), (2,0), (3,1), (4,1), (5,1)\}$
以下、$(x_i,y_i)$は$i$番目のデータを表します。
例えば、$(1,0)$は$x=1$の時、$3x$が$5$を超えないため、正解の確率として$0$を表します。
$(3,1)$は$x=3$の時、$3x$が$5$を超えるため、正解の確率として$1$を表します。

このデータセットを使って、$w,b$を更新していくことで、AIが学習を行います。
具体的には、各データの正解$y$と比較して、予測値$\hat{y}$が最も「尤もらしく」（もっともらしく）なるように$w,b$を更新していきます。
尤もらしさを表す関数として、**尤度関数**を定義します。

$$
P(\hat{y}_i|w,b) = \hat{y}_i^{y_i} (1-\hat{y}_i)^{1-y_i}
$$

この関数は値が大きいほど予測が尤もらしいことを示します。データの$y_i$が$1$の時、出力される確率は高いほど尤もらしいです。逆に、データの$y_i$が$0$の時、出力される確率は低いほど尤もらしいです。
この性質をうまく利用して$P(\hat{y}_i|w,b)$は定義されています。
この尤度関数を最大化するような$w,b$を求めることが学習の目的です。
$P(\hat{y}_i|w,b)$を最大化するにあたって、微分を使って、停留点を求めるなどをして解析的に求めることもできますが、AIの複雑度が増したときに、全てのパラメータについて解析的に求めることが困難になるため、大量のデータを使って$w,b$を更新していくことが一般的です。
このように、$w,b$を更新していくことを**学習**といいます。

パラメータの更新は、高校数学の分野で言う、ニュートン法の発想と感覚が近いです。

::: details ニュートン法とは
ニュートン法とは、関数$F(x)=0$の解を解析的に求めることなく、
初期値$x_0$から出発して、$F(x)=0$の解に収束するように$x$を更新していく方法です。
具体的には、$F(x)$の接線のx軸との交点を新しい$x$として更新していきます。
更に詳しく知りたい人は、ニュートン法で検索してみてください。
:::

ニュートン法では、$F(x)=0$の解を解析的に求めることが出来ないにもかかわらず、何度も更新を繰り返すことで、$x$を$F(x)=0$となる$x$に収束することができます。
しかし、AIにおける学習は、ニュートン法とは異なり、最急降下法という方法によって行われます。
最急降下法は、関数$F(x)$の最小値を求めるために、関数の勾配（傾き）を使って、徐々に最小値に近づいていく方法です。
ある出発点$x_0$から、関数$F(x)$の勾配を計算し、その勾配の逆方向に少しずつ$x$を更新していきます。この更新を繰り返すことで、最終的に$F(x)$の最小値に収束することができます。

![最急降下法](/images/articles/ai_understanding/dL.png =400x)

AIの学習において最急降下法を用いる時、$w,b$を更新する際には、ある関数$\mathcal{L}(w,b)$を定義して、それを最小化するように更新する問題に帰着されます。
この関数$\mathcal{L}(w,b)$を**損失関数**といいます。
この損失関数を、値が大きいほど、AIの予測が正解から外れていることを示すように設計したいです。

ここで、先ほど定義した尤度関数を使って、損失関数の設計を考えると、尤もらしいほど損失が小さく、尤もらしくないほど損失が大きいような関数を設計することができます。
よって、尤度にマイナスをかけたものを損失関数として設計することを考えて以下のように定義します。

$$
\mathcal{L}(w,b) = - log P(\hat{y}_i|w,b) = -y_i log \hat{y}_i - (1-y_i) log(1-\hat{y}_i)
$$

(ここで、対数を用いるのは、扱いやすくするためです。logは単調増加関数であるため、大小関係は特に変わりません。)

この損失関数を最小化するように$w,b$を更新していくことで、AIが学習を行います。

実際にパラメータを更新してみましょう

1. パラメータの初期化: $w=1, b=0$

2. w の更新: $w = w - \alpha \frac{\partial \mathcal{L}(w,b)}{\partial w}$

3. b の更新: $b = b - \alpha \frac{\partial \mathcal{L}(w,b)}{\partial b}$

4. 2,3を、パラメータが収束するまで繰り返す

ここで、$\alpha$は学習率と呼ばれるハイパーパラメータで、更新の大きさを調整するために使います。
また、$\frac{\partial \mathcal{L}(w,b)}{\partial w}, \frac{\partial \mathcal{L}(w,b)}{\partial b}$は、それぞれ$w,b$に関する損失関数の勾配を表します。
($\partial$は偏微分を表し、$w$以外のパラメータは一定として微分を行うことです。詳しくは偏微分で検索してみてください。)
これらの勾配は、微分を使って計算することができます。

::: details 勾配の計算
損失関数$\mathcal{L}(w,b)$を$w$について微分すると、以下のようになります。

まず事前準備として、以下の微分を計算します。

$$
\begin{align*}
\frac{\partial \mathcal{L}(w,b)}{\partial \hat{y}_i} &= -\frac{y_i}{\hat{y}_i} + \frac{1-y_i}{1-\hat{y}_i}\\
\frac{\partial \hat{y}_i}{\partial z} &= -\frac 1 {(1+e^{-z})^2} e^{-z} = \frac 1 {1+e^{-z}} (1-\frac 1 {1+e^{-z}}) = \hat{y}_i (1-\hat{y}_i)\\
\frac{\partial z}{\partial w} &= x_i\\
\frac{\partial z}{\partial b} &= 1
\end{align*}
$$

これらを使って、$w$についての損失関数の微分を計算します。

$$
\begin{align*}
\frac{\partial \mathcal{L}(w,b)}{\partial w} &= \frac{\partial \mathcal{L}(w,b)}{\partial \hat{y}_i} \frac{\partial \hat{y}_i}{\partial z} \frac{\partial z}{\partial w} \\
&= (-\frac{y_i}{\hat{y}_i} + \frac{1-y_i}{1-\hat{y}_i}) \hat{y}_i (1-\hat{y}_i) x_i\\
&= (\hat{y}_i - y_i) x_i
\end{align*}
$$

同様に、$b$についての損失関数の微分を計算します。

$$
\begin{align*}
\frac{\partial \mathcal{L}(w,b)}{\partial b} &= \frac{\partial \mathcal{L}(w,b)}{\partial \hat{y}_i} \frac{\partial \hat{y}_i}{\partial z} \frac{\partial z}{\partial b} \\
&= (-\frac{y_i}{\hat{y}_i} + \frac{1-y_i}{1-\hat{y}_i}) \hat{y}_i (1-\hat{y}_i)\\
&= \hat{y}_i - y_i
\end{align*}
$$

よって、更新式は以下のようになります。

$$
w \leftarrow w - \alpha (\hat{y}_i - y_i) x_i \\
b \leftarrow b - \alpha (\hat{y}_i - y_i)
$$


:::

このように、データを使うことによって、そのデータに適合するようにパラメータが更新されていくことで学習されることが分かります。

ここで次節の事前準備として、このモデル全体をグラフィカルに表現してみましょう。

![単純なネットワーク](/images/articles/ai_understanding/simple_network.png =500x)

## 実際に用いられるAI
実際に用いられるAIは、このような単純な問題ではなく、画像認識、音声認識、自然言語処理、予測分析など、多様な問題に対応するために、複雑なモデルが使われます。
最初の例で述べた画像に書かれた数字を判別する物も入力変数も784個の数値で入力されるため、それに応じたパラメータ数が必要になります。
また、関数$F(\cdot)$の中身も、先ほど扱った$wx+b$のように線形な関数ではなく、より複雑にするように設計される必要があります。

![複雑なネットワーク](/images/articles/ai_understanding/complex_network.png)

この図にある$f$は、活性化関数と呼ばれ、非線形性を持たせるための関数です。

::: details 非線形性を持たせるとは

線形性とは、入力変数$x$に対して、$y=ax+b$のように、$x$に比例して$y$が変化する関数のことです。一方、非線形性とは、$y=ax^2+b$のように、$x$に比例していない関数のことです。
AIのモデルには、非線形性を持たせることで、複雑な問題に対応することができます。
活性化関数がない場合、ネットワーク全体を表すF（以降、モデルとする）としては、単なる線形関数としてしか表現することができません。
具体的には、

$$
\begin{align*}
F(x) &= w_3(w_2(w_1x+b_1)+b_2)+b_3\\
&= w_3w_2w_1x + w_3w_2b_1 + w_3b_2 + b_3
&= w'x + b'
\end{align*}
$$

のように、どれだけ層を重ねても、線形関数でしか表現することができません。そのため、活性化関数を計算の途中に挟み、非線形性を持たせることで、複雑な問題に対応することができます。

また汎用的に使われる活性化関数の例として、ReLU関数があります。
ReLU関数は以下のように定義されています。

$$
f(x) = \begin{cases}
x & (x > 0)\\
0 & (x \leq 0)
\end{cases}
$$

ReLU関数は、入力が0以上の時、そのまま出力し、0未満の時、0を出力する関数です。
この関数が汎用的に使われているのは、微分が簡単であり、計算が高速であるためです。

:::

この図に示すように、ユニットを多層に重ねたり、非線形な関数を使ったりすることで、複雑なタスクに対応できるようになります。我々が便利に使えるようにするためには、更に複雑なモデルが必要になります。
ChatGPTなどの自然言語処理のAIは、RNNと呼ばれる出力されたものを次の入力に使ったり、画像認識のためのAIは、CNNと呼ばれる、画像の部分的な特徴を抽出して、それを次の層に渡すなど様々な工夫によってモデルをより複雑にすることで、複雑な問題に対応できるようにします。


## まとめ
AIにおける学習とは、与えられたデータに適合するように、モデルのパラメータを更新していくことです。
この学習は、最急降下法を使って、損失関数を最小化するようにパラメータを更新していきます。
我々が日常的に使えるようにするためには、非常に自由度の高い複雑なネットワークを構成して、より柔軟に様々なタスクに対応できるようにします。
しかしながら、AIの学習の観点からは、**損失関数をうまく設計すること**ができさえすれば、どのようなモデルを使っても、データに適合するようにパラメータが更新されるため、学習を行うことができます。






